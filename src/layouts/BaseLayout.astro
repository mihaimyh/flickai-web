---
import '../styles/global.css';
import '../style.css';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import ClientScripts from '../components/ClientScripts.astro';
import { getTranslations, getLangPrefix, type TranslationData } from '../utils/i18n';
import { SUPPORTED_LOCALES, type SupportedLocale } from '../i18n-config';

interface Props {
  title: string;
  description: string;
  keywords?: string;
  ogTitle?: string;
  ogDescription?: string;
  ogImage?: string;
  ogType?: string;
  canonicalUrl?: string;
  lang?: string;
  translations?: TranslationData;
}

const {
  title,
  description,
  keywords,
  ogTitle,
  ogDescription,
  ogImage = 'https://flickai.net/images/social-preview.jpg',
  ogType = 'website',
  canonicalUrl,
  lang = 'en',
  translations: providedTranslations
} = Astro.props;

// Use ogTitle/ogDescription if provided, otherwise fall back to title/description
const finalOgTitle = ogTitle || title;
const finalOgDescription = ogDescription || description;

// Load translations if not provided (synchronous now)
const translations = providedTranslations || getTranslations(lang);
const locale = lang as SupportedLocale;
const langPrefix = getLangPrefix(locale);

const locales = SUPPORTED_LOCALES;
const currentPath = Astro.url.pathname;
const baseUrl = 'https://flickai.net';

// Helper to get clean path without locale prefix for hreflang generation
function getCleanPath(pathname: string, currentLocale: SupportedLocale): string {
  // Remove leading/trailing slashes
  let cleanPath = pathname.replace(/^\/+|\/+$/g, '');
  
  // Remove locale prefix if present (except for root)
  if (currentLocale !== 'en' && cleanPath.startsWith(`${currentLocale}/`)) {
    cleanPath = cleanPath.replace(new RegExp(`^${currentLocale}\\/`), '');
  }
  
  // Ensure path starts with / and ends with / (for directory format)
  if (cleanPath === '') {
    return '/';
  }
  return `/${cleanPath}/`;
}

// Get clean path without current locale prefix
const cleanPath = getCleanPath(currentPath, locale);

// Auto-generate canonical URL if not provided
const finalCanonicalUrl = canonicalUrl || `${baseUrl}${currentPath === '/' ? '/' : currentPath}`;
---

<!DOCTYPE html>
<html lang={lang} dir={lang === 'ar' ? 'rtl' : 'ltr'}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#3b82f6" />
    
    <link rel="icon" type="image/jpeg" href="/favicon.jpg" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    
    <title>{title}</title>
    <meta name="description" content={description} />
    {keywords && <meta name="keywords" content={keywords} />}
    <meta name="author" content="FlickAI Team" />
    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
    
    <link rel="canonical" href={finalCanonicalUrl} />
    <link rel="sitemap" type="application/xml" title="Sitemap" href={`${baseUrl}/sitemap.xml`} />
    
    <!-- Redirect .html URLs to clean URLs (for live site with indexed .html URLs) -->
    <script is:inline>
      // Redirect old .html URLs to clean URLs with trailing slashes
      (function() {
        const path = window.location.pathname;
        // Only redirect if path ends with .html (excluding index.html at root)
        if (path.endsWith('.html') && path !== '/index.html') {
          // Replace .html with trailing slash, preserving query string and hash
          const cleanPath = path.replace(/\.html$/, '/');
          const newUrl = cleanPath + window.location.search + window.location.hash;
          // Use replace instead of assign to avoid adding to history
          window.location.replace(newUrl);
        }
      })();
    </script>
    
    <!-- Hreflang Tags -->
    {locales.map((loc) => {
      const localePath = loc === 'en' ? '' : `/${loc}`;
      const fullPath = cleanPath === '/' && loc === 'en' ? '/' : `${localePath}${cleanPath}`;
      return (
        <link 
          rel="alternate" 
          hreflang={loc} 
          href={`${baseUrl}${fullPath}`} 
        />
      );
    })}
    <link rel="alternate" hreflang="x-default" href={`${baseUrl}${cleanPath === '/' ? '/' : cleanPath}`} />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content={ogType} />
    <meta property="og:url" content={`${baseUrl}${currentPath}`} />
    <meta property="og:title" content={finalOgTitle} />
    <meta property="og:description" content={finalOgDescription} />
    <meta property="og:image" content={ogImage} />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={`${baseUrl}${currentPath}`} />
    <meta property="twitter:title" content={finalOgTitle} />
    <meta property="twitter:description" content={finalOgDescription} />
    <meta property="twitter:image" content={ogImage} />
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Outfit:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
    
    <slot name="head" />
  </head>
  <body>
    <div id="app">
      <Header translations={translations} lang={locale} langPrefix={langPrefix} />
      
      <slot />
      
      <Footer translations={translations} langPrefix={langPrefix} />
    </div>
    
    <!-- Client-side script for animations and interactivity -->
    <script is:inline>
      // Make fade-in elements visible - run immediately, don't wait for DOMContentLoaded
      (function() {
        function initAnimations() {
          // IntersectionObserver for fade-in animations
          const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
          };
          
          const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                entry.target.classList.add('visible');
              }
            });
          }, observerOptions);
          
          // Initialize animations for fade-in elements
          const animatedElements = document.querySelectorAll('.fade-in');
          animatedElements.forEach(el => {
            observer.observe(el);
            // If elements are already in viewport, make them visible immediately
            const rect = el.getBoundingClientRect();
            if (rect.top < (window.innerHeight || document.documentElement.clientHeight) && rect.bottom > 0) {
              el.classList.add('visible');
            }
          });
        }
        
        // Run immediately if DOM is ready, otherwise wait
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initAnimations);
        } else {
          // DOM already loaded, run immediately
          initAnimations();
        }
      })();
    </script>
    
    <!-- Load main.ts for FAB buttons, language switcher, and download dialog -->
    <ClientScripts />
  </body>
</html>
